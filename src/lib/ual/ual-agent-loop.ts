import { UALClient, WebAction, UALResult, AgentStep } from '@/lib/universal-action-layer';

export class UALAgentLoop {
    private client: UALClient;
    private maxSteps: number = 15;
    private isRunning: boolean = false;

    constructor() {
        this.client = new UALClient();
    }

    async run(
        goal: string,
        onStep: (step: AgentStep) => void
    ) {
        if (this.isRunning) return;
        this.isRunning = true;

        let stepCount = 0;
        const sessionId = `agent-${Math.random().toString(36).substring(2, 9)}`;
        let currentState: { url?: string; title?: string; text?: string; botStatus?: string } = {};
        const actionHistory: any[] = [];

        try {
            while (stepCount < this.maxSteps && this.isRunning) {
                stepCount++;

                // 1. PLANNING
                onStep({
                    type: 'planning',
                    message: `Planning step ${stepCount} for goal: ${goal}`,
                    timestamp: Date.now()
                });

                // Pass context (url, title, snippet, botStatus) AND HISTORY to planner
                const plan = await this.client.planActions(goal, currentState.url, currentState, actionHistory);
                const { actions, status, reasoning } = plan;

                if (status === 'COMPLETED') {
                    onStep({
                        type: 'completed',
                        message: plan.answer || reasoning || 'Goal achieved successfully.',
                        timestamp: Date.now()
                    });
                    break;
                }

                if (!actions || actions.length === 0) {
                    onStep({
                        type: 'failed',
                        message: 'No actions generated by the planner.',
                        timestamp: Date.now()
                    });
                    break;
                }

                onStep({
                    type: 'executing',
                    message: reasoning || `Executing ${actions.length} actions...`,
                    actions,
                    timestamp: Date.now()
                });

                // 2. EXECUTING
                const result: UALResult = await this.client.executeTask({
                    goal,
                    sessionId,
                    url: currentState.url,
                    actions
                });

                // Record actions AND RESULT to history
                // This is critical for the planner to know if it failed
                const executionResult = result.success
                    ? (result.data?.botStatus === "BLOCK_DETECTED" ? "FAILED: BLOCKED" : "SUCCESS")
                    : `FAILED: ${result.error}`;

                actionHistory.push({ step: stepCount, actions, reasoning, result: executionResult });

                // 3. OBSERVING
                const obsMessage = result.data?.botStatus === "BLOCK_DETECTED"
                    ? `⚠️ BOT BLOCK DETECTED on ${result.data?.title || 'Unknown Page'}`
                    : `Observed: ${result.data?.title || 'Unknown Page'}`;

                onStep({
                    type: 'observing',
                    message: obsMessage,
                    screenshot: result.screenshot,
                    timestamp: Date.now()
                });

                // 4. VERIFICATION & SELF-CORRECTION (The Brain)
                if ((plan as any).verification) {
                    const criteria = (plan as any).verification.criteria;
                    const question = (plan as any).verification.question;

                    // Simple text-based verification for now
                    const pageText = result.data?.text || result.data?.title || '';
                    const isBlocked = pageText.includes("Just a moment") || pageText.includes("Access Denied") || pageText.includes("Security Check");

                    if (isBlocked) {
                        onStep({
                            type: 'failed',
                            message: "⚠️ Anti-Bot Block Detected. Hard switching strategy...",
                            timestamp: Date.now()
                        });

                        // CRITICAL: Overwrite the last history entry to ensure the planner sees the BLOCK failure
                        if (actionHistory.length > 0) {
                            actionHistory[actionHistory.length - 1].result = "FAILED: BLOCKED BY CLOUDFLARE/CAPTCHA. DO NOT RETRY THIS URL. NAVIGATE TO GOOGLE.";
                        }

                        // Hard wait to reset
                        await new Promise(r => setTimeout(r, 3000));
                        continue; // Re-plan immediately
                    }
                }

                if (!result.success) {
                    onStep({
                        type: 'failed',
                        message: result.error || 'Execution failed.',
                        timestamp: Date.now()
                    });
                    break;
                }

                // Update state for next iteration
                if (result.data) {
                    currentState = {
                        url: result.data.url,
                        title: result.data.title,
                        text: result.data.text,
                        botStatus: result.data.botStatus
                    };
                }

                // Support for auto-finishing if reasoning suggests it
                if (status === 'COMPLETED') break;

                // Small delay between steps
                await new Promise(r => setTimeout(r, 2000));
            }

            if (stepCount >= this.maxSteps) {
                onStep({
                    type: 'failed',
                    message: 'Reached maximum steps without achieving goal.',
                    timestamp: Date.now()
                });
            }
        } catch (error: any) {
            onStep({
                type: 'failed',
                message: `Loop crashed: ${error.message}`,
                timestamp: Date.now()
            });
        } finally {
            this.isRunning = false;
        }
    }

    stop() {
        this.isRunning = false;
    }

    private async evaluateProgress(goal: string, result: UALResult): Promise<boolean> {
        // In a production version, we'd call an LLM to check if the goal is met based on the screenshot and data.
        // For this MVP, we'll look for success and extracted data.
        if (!result.success) return false;

        // If the planner thinks it's done, it should signal somehow. 
        // Usually, if we have extracted data that looks relevant to the goal, we are close.
        // We'll let it run for a few steps for better demo visual.
        return false; // Iterative by default
    }
}
