import { UALClient, WebAction, UALResult, AgentStep } from '@/lib/universal-action-layer';

export class UALAgentLoop {
    private client: UALClient;
    private maxSteps: number = 15;
    private isRunning: boolean = false;
    private actionHistory: string[] = [];
    private ws: WebSocket | null = null;
    private steps: any[] = []; // Added based on usage in run method

    constructor() {
        this.client = new UALClient();
        this.initDesktopBridge();
    }

    public isBridgeConnected(): boolean {
        return this.ws !== null && this.ws.readyState === WebSocket.OPEN;
    }

    // Initialize connection to local desktop bridge
    private initDesktopBridge() {
        if (typeof WebSocket !== 'undefined') {
            this.ws = new WebSocket('ws://localhost:3001');
            this.ws.onopen = () => console.log('üîå Connected to Desktop Bridge');
            this.ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                const resolver = this.pendingRequests.get(data.id);
                if (resolver) {
                    resolver(data);
                    this.pendingRequests.delete(data.id);
                }
            };
            this.ws.onerror = (e) => console.log('‚ö†Ô∏è Desktop Bridge Offline (Run: node src/server/desktop-bridge.js)');
        }
    }

    private pendingRequests = new Map<string, (val: any) => void>();

    private async executeLocalAction(payload: any): Promise<UALResult> {
        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
            throw new Error("Bridge offline");
        }

        const id = Math.random().toString(36).substring(7);
        const promise = new Promise<any>((resolve) => {
            this.pendingRequests.set(id, resolve);
        });

        this.ws.send(JSON.stringify({ ...payload, id }));

        const response = await promise;

        if (response.status === 'error') {
            return { success: false, error: response.error, steps: [] };
        }

        return {
            success: true,
            screenshot: response.data?.screenshot,
            domTree: response.data?.domTree,
            data: response.data,
            steps: [`Local Action Success: ${payload.type}`]
        };
    }

    async run(
        goal: string,
        onStep: (step: AgentStep) => void
    ) {
        if (this.isRunning) return;
        this.isRunning = true;
        this.steps = [];
        this.actionHistory = [];

        // Re-init if closed
        if (this.ws?.readyState !== WebSocket.OPEN) this.initDesktopBridge();

        let stepCount = 0;
        const sessionId = `agent-${Math.random().toString(36).substring(2, 9)}`;
        let currentState: { url?: string; title?: string; text?: string; botStatus?: string } = {};
        // const actionHistory: any[] = []; // This was removed as it's now a class member

        try {
            while (stepCount < this.maxSteps && this.isRunning) {
                stepCount++;

                // 1. PLANNING
                onStep({
                    type: 'planning',
                    message: `Planning step ${stepCount} for goal: ${goal}`,
                    timestamp: Date.now()
                });

                // Pass context (url, title, snippet, botStatus) AND HISTORY to planner
                const plan = await this.client.planActions(goal, currentState.url, currentState, this.actionHistory);
                const { actions, status, reasoning } = plan;

                if (status === 'COMPLETED') {
                    onStep({
                        type: 'completed',
                        message: plan.answer || reasoning || 'Goal achieved successfully.',
                        timestamp: Date.now()
                    });
                    break;
                }

                if (!actions || actions.length === 0) {
                    onStep({
                        type: 'failed',
                        message: 'No actions generated by the planner.',
                        timestamp: Date.now()
                    });
                    break;
                }

                onStep({
                    type: 'executing',
                    message: reasoning || `Executing ${actions.length} actions...`,
                    actions,
                    timestamp: Date.now()
                });

                // 2. EXECUTING
                let finalResult: UALResult = { success: false, error: 'No actions executed', steps: [] };

                for (const nextAction of actions) {
                    // Check if stop was requested
                    if (!this.isRunning) {
                        finalResult = { success: false, error: 'Stopped by user', steps: [] };
                        break;
                    }

                    // 3. EXECUTION PHASE
                    onStep({ type: 'executing', message: `Executing: ${nextAction.type}`, timestamp: Date.now(), actions: [nextAction] });

                    let result: UALResult;
                    const action = nextAction as any;

                    // PREFER LOCAL BRIDGE FOR ALL ACTIONS
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        try {
                            if (action.type === 'navigate') {
                                result = await this.executeLocalAction({ type: 'BROWSER_NAVIGATE', url: action.url });
                            } else if (action.type === 'click') {
                                if (action.x !== undefined) {
                                    result = await this.executeLocalAction({ type: 'MOUSE_MOVE', x: action.x, y: action.y });
                                } else {
                                    result = await this.executeLocalAction({ type: 'BROWSER_CLICK', selector: action.selector });
                                }
                            } else if (action.type === 'type') {
                                if (action.selector) {
                                    result = await this.executeLocalAction({ type: 'BROWSER_TYPE', selector: action.selector, text: action.value || action.text });
                                } else {
                                    result = await this.executeLocalAction({ type: 'TYPE', text: action.value || action.text });
                                }
                            } else if (action.type === 'desktop_run') {
                                result = await this.executeLocalAction({ type: 'RUN_TERMINAL', command: action.command });
                            } else if (action.type === 'desktop_key') {
                                result = await this.executeLocalAction({ type: 'KEY_PRESS', key: action.key });
                            } else {
                                // Fallback for other standard actions
                                result = await this.executeLocalAction({ type: 'BROWSER_OBSERVE' });
                            }
                        } catch (e: any) {
                            console.error("Local execution failed, falling back to server:", e);
                            result = await this.client.executeTask({ goal, sessionId, actions: [nextAction] });
                        }
                    } else {
                        // STANDARD REMOTE BROWSER ACTION
                        result = await this.client.executeTask({ goal, sessionId, actions: [nextAction] });
                    }

                    if (!result.success) {
                        finalResult = result;
                        break;
                    }
                    finalResult = result;
                }

                const result: UALResult = finalResult;

                // Record actions AND RESULT to history
                // This is critical for the planner to know if it failed
                const executionResult = result.success
                    ? (result.data?.botStatus === "BLOCK_DETECTED" ? "FAILED: BLOCKED" : "SUCCESS")
                    : `FAILED: ${result.error}`;

                this.actionHistory.push(JSON.stringify({ step: stepCount, actions, reasoning, result: executionResult }));

                // 3. OBSERVING
                const obsMessage = result.data?.botStatus === "BLOCK_DETECTED"
                    ? `‚ö†Ô∏è BOT BLOCK DETECTED on ${result.data?.title || 'Unknown Page'}`
                    : `Observed: ${result.data?.title || 'Unknown Page'}`;

                onStep({
                    type: 'observing',
                    message: obsMessage,
                    screenshot: result.screenshot,
                    timestamp: Date.now()
                });

                // 4. VERIFICATION & SELF-CORRECTION (The Brain)
                if ((plan as any).verification) {
                    const criteria = (plan as any).verification.criteria;
                    const question = (plan as any).verification.question;

                    // Simple text-based verification for now
                    const pageText = result.data?.text || result.data?.title || '';
                    const isBlocked = pageText.includes("Just a moment") || pageText.includes("Access Denied") || pageText.includes("Security Check");

                    if (isBlocked) {
                        onStep({
                            type: 'failed',
                            message: "‚ö†Ô∏è Anti-Bot Block Detected. Hard switching strategy...",
                            timestamp: Date.now()
                        });

                        // CRITICAL: Overwrite the last history entry to ensure the planner sees the BLOCK failure
                        if (this.actionHistory.length > 0) {
                            // Parse because it's stored as string now
                            const lastEntry = JSON.parse(this.actionHistory[this.actionHistory.length - 1]);
                            lastEntry.result = "FAILED: BLOCKED BY CLOUDFLARE/CAPTCHA. DO NOT RETRY THIS URL. NAVIGATE TO GOOGLE.";
                            this.actionHistory[this.actionHistory.length - 1] = JSON.stringify(lastEntry);
                        }

                        // Hard wait to reset
                        await new Promise(r => setTimeout(r, 3000));
                        continue; // Re-plan immediately
                    }
                }

                if (!result.success) {
                    onStep({
                        type: 'failed',
                        message: result.error || 'Execution failed.',
                        timestamp: Date.now()
                    });
                    break;
                }

                // Update state for next iteration
                if (result.data) {
                    currentState = {
                        url: result.data.url,
                        title: result.data.title,
                        text: result.data.text,
                        botStatus: result.data.botStatus
                    };
                }

                // Support for auto-finishing if reasoning suggests it
                if (status === 'COMPLETED') break;

                // Small delay between steps
                await new Promise(r => setTimeout(r, 2000));
            }

            if (stepCount >= this.maxSteps) {
                onStep({
                    type: 'failed',
                    message: 'Reached maximum steps without achieving goal.',
                    timestamp: Date.now()
                });
            }
        } catch (error: any) {
            onStep({
                type: 'failed',
                message: `Loop crashed: ${error.message}`,
                timestamp: Date.now()
            });
        } finally {
            this.isRunning = false;
        }
    }

    stop() {
        this.isRunning = false;
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            // Optional: send a stop signal to the browser if needed
        }
    }

    private async evaluateProgress(goal: string, result: UALResult): Promise<boolean> {
        // In a production version, we'd call an LLM to check if the goal is met based on the screenshot and data.
        // For this MVP, we'll look for success and extracted data.
        if (!result.success) return false;

        // If the planner thinks it's done, it should signal somehow. 
        // Usually, if we have extracted data that looks relevant to the goal, we are close.
        // We'll let it run for a few steps for better demo visual.
        return false; // Iterative by default
    }
}
