import { UALClient, WebAction, UALResult, AgentStep } from '@/lib/universal-action-layer';

export class UALAgentLoop {
    private client: UALClient;
    private maxSteps: number = 15;
    private isRunning: boolean = false;
    private actionHistory: string[] = [];
    private ws: WebSocket | null = null;
    private steps: any[] = []; // Added based on usage in run method

    constructor() {
        this.client = new UALClient();
        this.initDesktopBridge();
    }

    // Initialize connection to local desktop bridge
    private initDesktopBridge() {
        if (typeof WebSocket !== 'undefined') {
            this.ws = new WebSocket('ws://localhost:3001');
            this.ws.onopen = () => console.log('ðŸ”Œ Connected to Desktop Bridge');
            this.ws.onerror = (e) => console.log('âš ï¸ Desktop Bridge Offline (Run: node src/server/desktop-bridge.js)');
        }
    }

    async run(
        goal: string,
        onStep: (step: AgentStep) => void
    ) {
        if (this.isRunning) return;
        this.isRunning = true;
        this.steps = [];
        this.actionHistory = [];

        // Re-init if closed
        if (this.ws?.readyState !== WebSocket.OPEN) this.initDesktopBridge();

        let stepCount = 0;
        const sessionId = `agent-${Math.random().toString(36).substring(2, 9)}`;
        let currentState: { url?: string; title?: string; text?: string; botStatus?: string } = {};
        // const actionHistory: any[] = []; // This was removed as it's now a class member

        try {
            while (stepCount < this.maxSteps && this.isRunning) {
                stepCount++;

                // 1. PLANNING
                onStep({
                    type: 'planning',
                    message: `Planning step ${stepCount} for goal: ${goal}`,
                    timestamp: Date.now()
                });

                // Pass context (url, title, snippet, botStatus) AND HISTORY to planner
                const plan = await this.client.planActions(goal, currentState.url, currentState, this.actionHistory);
                const { actions, status, reasoning } = plan;

                if (status === 'COMPLETED') {
                    onStep({
                        type: 'completed',
                        message: plan.answer || reasoning || 'Goal achieved successfully.',
                        timestamp: Date.now()
                    });
                    break;
                }

                if (!actions || actions.length === 0) {
                    onStep({
                        type: 'failed',
                        message: 'No actions generated by the planner.',
                        timestamp: Date.now()
                    });
                    break;
                }

                onStep({
                    type: 'executing',
                    message: reasoning || `Executing ${actions.length} actions...`,
                    actions,
                    timestamp: Date.now()
                });

                // 2. EXECUTING
                let finalResult: UALResult = { success: false, error: 'No actions executed', steps: [] };

                for (const nextAction of actions) {
                    // Check if stop was requested
                    if (!this.isRunning) {
                        finalResult = { success: false, error: 'Stopped by user', steps: [] };
                        break;
                    }

                    // 3. EXECUTION PHASE
                    onStep({ type: 'executing', message: `Executing: ${nextAction.type}`, timestamp: Date.now(), actions: [nextAction] });

                    let result: UALResult;
                    const action = nextAction as any;

                    // DESKTOP ACTION HANDLER
                    if (action.type.startsWith('desktop_') || (action.type === 'click' && action.x !== undefined) || (action.type === 'type' && !action.selector)) {
                        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                            const payload: any = { type: 'UNKNOWN', ...action };

                            // Map Planner Actions to Bridge Commands
                            if (action.type === 'desktop_run') {
                                payload.type = 'RUN_TERMINAL';
                                payload.command = action.command;
                            } else if (action.type === 'desktop_key') {
                                payload.type = 'KEY_PRESS';
                                payload.key = action.key;
                            } else if (action.type === 'click' && action.x !== undefined) {
                                this.ws.send(JSON.stringify({ type: 'MOUSE_MOVE', x: action.x, y: action.y }));
                                await new Promise(r => setTimeout(r, 100));
                                payload.type = 'CLICK';
                            } else if (action.type === 'desktop_type' || (action.type === 'type' && !action.selector)) {
                                payload.type = 'TYPE';
                                payload.text = action.text || action.value;
                            }

                            this.ws.send(JSON.stringify(payload));
                            result = {
                                success: true,
                                steps: [`Desktop action: ${action.type}`],
                                data: { title: 'Desktop Action Executed', url: 'desktop://', text: 'Action completed' }
                            };
                            await new Promise(r => setTimeout(r, 800));
                        } else {
                            result = { success: false, error: 'Desktop Bridge not connected', steps: [] };
                        }
                    } else {
                        // STANDARD BROWSER ACTION
                        result = await this.client.executeTask({ goal, sessionId, actions: [nextAction] });
                    }

                    if (!result.success) {
                        finalResult = result;
                        break;
                    }
                    finalResult = result;
                }

                const result: UALResult = finalResult;

                // Record actions AND RESULT to history
                // This is critical for the planner to know if it failed
                const executionResult = result.success
                    ? (result.data?.botStatus === "BLOCK_DETECTED" ? "FAILED: BLOCKED" : "SUCCESS")
                    : `FAILED: ${result.error}`;

                this.actionHistory.push(JSON.stringify({ step: stepCount, actions, reasoning, result: executionResult }));

                // 3. OBSERVING
                const obsMessage = result.data?.botStatus === "BLOCK_DETECTED"
                    ? `âš ï¸ BOT BLOCK DETECTED on ${result.data?.title || 'Unknown Page'}`
                    : `Observed: ${result.data?.title || 'Unknown Page'}`;

                onStep({
                    type: 'observing',
                    message: obsMessage,
                    screenshot: result.screenshot,
                    timestamp: Date.now()
                });

                // 4. VERIFICATION & SELF-CORRECTION (The Brain)
                if ((plan as any).verification) {
                    const criteria = (plan as any).verification.criteria;
                    const question = (plan as any).verification.question;

                    // Simple text-based verification for now
                    const pageText = result.data?.text || result.data?.title || '';
                    const isBlocked = pageText.includes("Just a moment") || pageText.includes("Access Denied") || pageText.includes("Security Check");

                    if (isBlocked) {
                        onStep({
                            type: 'failed',
                            message: "âš ï¸ Anti-Bot Block Detected. Hard switching strategy...",
                            timestamp: Date.now()
                        });

                        // CRITICAL: Overwrite the last history entry to ensure the planner sees the BLOCK failure
                        if (this.actionHistory.length > 0) {
                            // Parse because it's stored as string now
                            const lastEntry = JSON.parse(this.actionHistory[this.actionHistory.length - 1]);
                            lastEntry.result = "FAILED: BLOCKED BY CLOUDFLARE/CAPTCHA. DO NOT RETRY THIS URL. NAVIGATE TO GOOGLE.";
                            this.actionHistory[this.actionHistory.length - 1] = JSON.stringify(lastEntry);
                        }

                        // Hard wait to reset
                        await new Promise(r => setTimeout(r, 3000));
                        continue; // Re-plan immediately
                    }
                }

                if (!result.success) {
                    onStep({
                        type: 'failed',
                        message: result.error || 'Execution failed.',
                        timestamp: Date.now()
                    });
                    break;
                }

                // Update state for next iteration
                if (result.data) {
                    currentState = {
                        url: result.data.url,
                        title: result.data.title,
                        text: result.data.text,
                        botStatus: result.data.botStatus
                    };
                }

                // Support for auto-finishing if reasoning suggests it
                if (status === 'COMPLETED') break;

                // Small delay between steps
                await new Promise(r => setTimeout(r, 2000));
            }

            if (stepCount >= this.maxSteps) {
                onStep({
                    type: 'failed',
                    message: 'Reached maximum steps without achieving goal.',
                    timestamp: Date.now()
                });
            }
        } catch (error: any) {
            onStep({
                type: 'failed',
                message: `Loop crashed: ${error.message}`,
                timestamp: Date.now()
            });
        } finally {
            this.isRunning = false;
        }
    }

    stop() {
        this.isRunning = false;
    }

    private async evaluateProgress(goal: string, result: UALResult): Promise<boolean> {
        // In a production version, we'd call an LLM to check if the goal is met based on the screenshot and data.
        // For this MVP, we'll look for success and extracted data.
        if (!result.success) return false;

        // If the planner thinks it's done, it should signal somehow. 
        // Usually, if we have extracted data that looks relevant to the goal, we are close.
        // We'll let it run for a few steps for better demo visual.
        return false; // Iterative by default
    }
}
