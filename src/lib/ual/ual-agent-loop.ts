import { UALClient, WebAction, UALResult } from '@/lib/universal-action-layer';

export interface AgentStep {
    type: 'planning' | 'executing' | 'observing' | 'completed' | 'failed';
    message: string;
    screenshot?: string;
    actions?: WebAction[];
    timestamp: number;
}

export class UALAgentLoop {
    private client: UALClient;
    private maxSteps: number = 10;
    private isRunning: boolean = false;

    constructor() {
        this.client = new UALClient();
    }

    async run(
        goal: string,
        onStep: (step: AgentStep) => void
    ) {
        if (this.isRunning) return;
        this.isRunning = true;

        let currentUrl: string | undefined = undefined;
        let stepCount = 0;

        try {
            while (stepCount < this.maxSteps && this.isRunning) {
                stepCount++;

                // 1. PLANNING
                onStep({
                    type: 'planning',
                    message: `Planning step ${stepCount} for goal: ${goal}`,
                    timestamp: Date.now()
                });

                const actions = await this.client.planActions(goal, currentUrl);

                if (!actions || actions.length === 0) {
                    onStep({
                        type: 'failed',
                        message: 'No actions generated by the planner.',
                        timestamp: Date.now()
                    });
                    break;
                }

                onStep({
                    type: 'executing',
                    message: `Executing ${actions.length} actions...`,
                    actions,
                    timestamp: Date.now()
                });

                // 2. EXECUTING
                const result: UALResult = await this.client.executeTask({
                    goal,
                    url: currentUrl,
                    actions
                });

                // 3. OBSERVING
                onStep({
                    type: 'observing',
                    message: `Step ${stepCount} complete. Observing state...`,
                    screenshot: result.screenshot,
                    timestamp: Date.now()
                });

                if (!result.success) {
                    onStep({
                        type: 'failed',
                        message: result.error || 'Execution failed.',
                        timestamp: Date.now()
                    });
                    break;
                }

                // Update context for next iteration
                if (result.data?.url) {
                    currentUrl = result.data.url;
                }

                // Simple heuristic: If we have a screenshot and the planner didn't error, 
                // we check if the goal might be reached. 
                // In a real implementation, we'd have a 'critic' or 'evaluator' LLM call.
                // For now, if the planner returns a screenshot action as the last step, we'll consider it a good point to stop or continue.
                // BUT, since we want "Comet-like" behavior, we keep going until a terminal condition or max steps.

                // Check if goal is achieved (placeholder for LLM evaluation)
                const isGoalAchieved = await this.evaluateProgress(goal, result);
                if (isGoalAchieved) {
                    onStep({
                        type: 'completed',
                        message: 'Goal achieved successfully.',
                        timestamp: Date.now()
                    });
                    break;
                }

                // Small delay between steps
                await new Promise(r => setTimeout(r, 2000));
            }

            if (stepCount >= this.maxSteps) {
                onStep({
                    type: 'failed',
                    message: 'Reached maximum steps without achieving goal.',
                    timestamp: Date.now()
                });
            }
        } catch (error: any) {
            onStep({
                type: 'failed',
                message: `Loop crashed: ${error.message}`,
                timestamp: Date.now()
            });
        } finally {
            this.isRunning = false;
        }
    }

    stop() {
        this.isRunning = false;
    }

    private async evaluateProgress(goal: string, result: UALResult): Promise<boolean> {
        // In a production version, we'd call an LLM to check if the goal is met based on the screenshot and data.
        // For this MVP, we'll look for success and extracted data.
        if (!result.success) return false;

        // If the planner thinks it's done, it should signal somehow. 
        // Usually, if we have extracted data that looks relevant to the goal, we are close.
        // We'll let it run for a few steps for better demo visual.
        return false; // Iterative by default
    }
}
